`ViewRootImpl`是在`onCreate()`之后创建的，在`onResume()`的时候初始化的

`DecorView`是在`onCreate()`之前创建的.
`Theme`是加载在`DecorView`中的，`DecorView`在创建`PhoneWindow`的时候就会创建出来

在启动`Activity`的时候会调用
`scheduleLaunchActivity => handleLaunchActivity => performLaunchActivity`

在调用`performLaunchActivity`的时候会调用`attach()`把`window`和`activity`绑定,并且把`window`和`WMS`绑定

在此之后才会调用`onCreate()`进入生命周期



### Activity启动流程
**一切从ActivityThread开始, ActivityThread 中的private Activity performLaunchActivity (ActivityClientRecord r,Intent customIntent) 启动一个activity.**
```java
ActivityThread里有 
final ArrayMap<IBinder, ActivityClientRecord> mActivities = new ArrayMap<>();
```

#### 1. handleMessage
```java
ActivityThread里handleMessage(msg), 如果message是LAUNCH_ACTIVITY, 执行:

final ActivityClientRecord r = (ActivityClientRecord) msg.obj;

ActivityClientRecord是一个结构体, 里边有window, activity, parent, paused, stopped等.

然后调用handleLaunchActivity
```

#### 2. handleLaunchActivity
```java
先调用 WindowManagerGlobal.initialize()

然后调用performLaunchActivity, 见3

然后调用handleResumeActivity, 见4
```

#### 3. performLaunchActivity
```java
这里private Activity performLaunchActivity里, 根据已有参数, new一个activity, 然后调用:

Context appContext = createBaseContextForActivity(r,activity); 初始化context, 见3.0

activity.attach(appContext, ... ) 见 3.1

activity.performStart() 
```

##### 3.0. createBaseContextForActivity
```java
ContextImpl appContext =ContextImpl.createActivityContext(this, r.packageInfo,displayId, r.overrideConfig);

相当于new 一个ContextImpl. 
```

##### 3.1 Activity.attach()
```java
attachBaseContext(context): 

先生成mWindow, mWindow = new PhoneWindow();

mWindow.setCallback(this); 将mWindow中的mCallback设置为当前activity

然后调用mWindow的setWindowManager.  见3.2

mUiThread = Thread.currentThread() Thread.currentThread()  是指获取当前运行的线程对象

mMainThread= aThread;
```

##### 3.2 Window.setWindowManager(WindowManager wm)
```java
在window里面，会有一个WindowManager类型的成员叫做mWindowManager，它是在setWindowManager()里通过WindowManagerService这个binder通过远程调用来创建的一个WindowManagerImpl，而这个WindowManagerImpl内部会通过一个static的WindowManagerGlobal去做所有跟WindowManager有关的操作。 简而言之就是，activity中有个window，window中通过mGlobal来跟WMS交互。

mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);

createLocalWindowManager 就是 return一个新的new WindowManagerImpl(mDisplay,parentWindow);
```

#### 4. handleResumeActivity
```java
ActivityThread.java
public void handleResumeActivity(...){
    // onResume 回调
    ActivityClientRecord r = performResumeActivity(...)
    final Activity a = r.activity;
    if (r.window == null && !a.mFinished && willBeVisible) {
        r.window = r.activity.getWindow();
        View decor = r.window.getDecorView();
        ViewManager wm = a.getWindowManager();
        wm.addView(decor, l);// 重点
    }
}

先调用performResumeActivity(这里主要调activity的performResume)

然后获得 window, decor,调用Windowmanager的addView: wm.addView(decor,l); 见5
```

#### 5. addView
```java
WindowManager的addView是在WindowManagerGlobal里实现的:

new一个ViewRootImpl root; 然后最终调用: (这里的root是ViewRootImp, view是activity的decor)

mViews.add(view);

mRoots.add(root);

mParams.add(wparams);

然后:

root.setView(view) 见6

WindowsManagerGlobal里有重要的成员变量:

ArrayList<View> mViews = new ArrayList<View>();

ArrayList<ViewRootImp> mRoots = new ArrayList<ViewRootImpl>();

ArrayList<WindowManager.LayoutParams> mParams = new ArrayList<WindowManager.LayoutParams>
```

#### 6. setView
```java
终于到ViewRootImp了. 

setView主要做的是: 

mAttachInfo.mRootView= view;

mView= view;

mAdded=true;

// Schedule the first layout -before- adding to the window

// manager, to make sure we do the relayout before receiving

// any other events from the system.

requestLayout();

后来requestLayout呢, 里边就是调用checkThread, 然后scheduleTraversals
```



- `View`通过 `invalidate`重新绘制
![](https://s3.bmp.ovh/imgs/2022/08/01/8aef83a3a52c0693.png)

- `View`通过 `requestLayout`重新绘制

`View.requestLayout => ... =>ViewRootImpl.requestLayout() => ViewRootImpl.scheduleTraversals() =>` 后面就和`invalidate`大致一样


**区别**
但是在 `measure` 和 `layout` 过程中，只会对 `flag` 设置为 `FORCE_LAYOUT` 的情况进行重新测量和布局，而 `draw` 只会重绘 `flag` 为 `dirty` 的区域。

`requestLayout` 是用来设置 `FORCE_LAYOUT` 标志，`invalidate` 用来设置 `dirty` 标志。所以` requestLayout `只会触发 `measure` 和 `layout`，`invalidate` 只会触发 `draw`。

想要`ViewGroup`能够在`invalidate()`后调用`onDraw()`需要在`ViewGroup`初始化的时候调用`setWillNotDraw(false);`