## 10.2 Android的消息机制分析

### 10.2.1 ThreadLocal的工作原理
**作用**: 当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用ThreadLocal


#### 应用场景

##### Handler通信中使用
比如对于Handler来说，它需要获取当前线程的Looper，很显然Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以轻松实现Looper在线程中的存取。如果不采用ThreadLocal，那么系统就必须提供一个全局的哈希表供Handler查找指定线程的Looper，这样一来就必须提供一个类似于LooperManager的类了，但是系统并没有这么做而是选择了ThreadLocal，这就是ThreadLocal的好处。

##### 复杂逻辑下的对象传递,比如监听器的传递
- 有些时候一个线程中的任务过于复杂，这可能表现为函数调用栈比较深以及代码入口的多样性，在这种情况下，我们又需要监听器能够贯穿整个线程的执行过程.
- 采用ThreadLocal可以让监听器作为线程内的全局对象而存在，在线程内部只要通过get方法就可以获取到监听器。

**如果不采用ThreadLocal，那么我们能想到的可能是如下两种方法**：
1. 第一种方法是将监听器通过参数的形式在函数调用栈中进行传递
2. 第二种方法就是将监听器作为静态变量供线程访问。

**上述这两种方法都是有局限性的**
1. 第一种方法的问题是当函数调用栈很深的时候，通过函数参数来传递监听器对象这几乎是不可接受的，这会让程序的设计看起来很糟糕。
2. 第二种方法是可以接受的，但是这种状态是不具有可扩充性的，比如同时有两个线程在执行，那么就需要提供两个静态的监听器对象，如果有10个线程在并发执行呢？提供10个静态的监听器对象？这显然是不可思议的，而采用ThreadLocal，每个监听器对象都在自己的线程内部存储，根本就不会有方法2的这种问题。

**例子**
```java
public class SecondActivity extends AppCompatActivity {
    ...
    private ThreadLocal<Boolean> mBooleanThreadLocal = new ThreadLocal<Boolean>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        ...

        binding.btnThreadLocal.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                mBooleanThreadLocal.set(true);
                Log.d(TAG,"[Thread#main]mBooleanThreadLocal=" + mBooleanThreadLocal.get());
                new Thread("Thread#1") {
                    @Override
                    public void run() {
                        mBooleanThreadLocal.set(false);
                        Log.d(TAG,"[Thread#1]mBooleanThreadLocal=" + mBooleanThreadLocal.get());
                    };
                }.start();
                new Thread("Thread#2") {
                    @Override
                    public void run() {
                        Log.d(TAG,"[Thread#2]mBooleanThreadLocal=" + mBooleanThreadLocal.get());
                    };
                }.start();
            }
        });
    }
}
```
```java
D/SecondActivity: [Thread#main]mBooleanThreadLocal=true
D/SecondActivity: [Thread#1]mBooleanThreadLocal=false
D/SecondActivity: [Thread#2]mBooleanThreadLocal=null
```
**ThreadLocal线程隔离的大概原理**
ThreadLocal之所以有这么奇妙的效果，是因为不同线程访问同一个ThreadLocal的get方法，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值。很显然，不同线程中的数组是不同的，这就是为什么通过ThreadLocal可以在不同的线程中维护一套数据的副本并且彼此互不干扰。


#### ThreadLocal的方法

##### set方法
```java
public class ThreadLocal<T>{
    ...
    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }
    ...
}
```
在上面的set方法中，首先会通过getMap方法来获取当前线程中的ThreadLocal数据，如
何获取呢？其实获取的方式也是很简单的，在Thread类的内部有一个成员专门用于存储线
程的ThreadLocal的数据：ThreadLocal.ThreadLocalMap map，因此获取当前线程的ThreadLocal数据就变得异常简单了。如果map的值为null，那么就需要对其进行初
始化，初始化后再将ThreadLocal的值进行存储。下面看一下ThreadLocal的值到底是如何
在map中进行存储的。在map内部有一个数组：private Entry[] table;
ThreadLocal的值就存在在这个table数组中。

```java
ThreadLocal<T>的静态内部类:

static class ThreadLocalMap {
    ...
    private Entry[] table;
    ...
    private void set(ThreadLocal<?> key, Object value) {

        // We don't use a fast path as with get() because it is at
        // least as common to use set() to create new entries as
        // it is to replace existing ones, in which case, a fast
        // path would fail more often than not.

        Entry[] tab = table;
        int len = tab.length;
        int i = key.threadLocalHashCode & (len-1);

        for (Entry e = tab[i];
            e != null;
            e = tab[i = nextIndex(i, len)]) {
            ThreadLocal<?> k = e.get();

            if (k == key) {
                e.value = value;
                return;
            }

            if (k == null) {
                replaceStaleEntry(key, value, i);
                return;
            }
        }

        tab[i] = new Entry(key, value);
        int sz = ++size;
        if (!cleanSomeSlots(i, sz) && sz >= threshold)
            rehash();
    }

}
```
可以看出table是一个Entry数组，Enrty是一个键值对结构,通过键来找值,而数组的下标是当前线程的中ThreadLocal的hashCode和table的数组长度计算的

##### get方法
```java
public class ThreadLocal<T>{
    ...
    public T get() {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }
    private T setInitialValue() {
        T value = initialValue();
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
        return value;
    }
    protected T initialValue() {
        return null;
    }
    ...
}
```
如果当前线程的ThreadLocal中有对应key的值就直接返回，没有就先创建一个(null)，再返回.

```java
ThreadLocal的静态内部类:

static class ThreadLocalMap {
    private Entry getEntry(ThreadLocal<?> key) {
        int i = key.threadLocalHashCode & (table.length - 1);
        Entry e = table[i];
        // Android-changed: Use refersTo()
        if (e != null && e.refersTo(key))//查到了key
            return e;
        else
            return getEntryAfterMiss(key, i, e);
    }

    private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {
        Entry[] tab = table;
        int len = tab.length;

        while (e != null) {
            // Android-changed: Use refersTo()
            if (e.refersTo(key))//查key
                return e;
            if (e.refersTo(null))//查空
                expungeStaleEntry(i);//有key对null就把这个从数组中去除
            else
                i = nextIndex(i, len);
            e = tab[i];
        }
        return null;
    }
}
```
从ThreadLocal的set和get方法可以看出，它们所操作的对象都是当前线程的
localValues对象的table数组，因此在不同线程中访问同一个ThreadLocal的set和get方法，
它们对ThreadLocal所做的读/写操作仅限于各自线程的内部，这就是为什么ThreadLocal可
以在多个线程中互不干扰地存储和修改数据，理解ThreadLocal的实现方式有助于理解
Looper的工作原理。


#### 10.2.2 消息队列的工作原理
[详情见](./Handler%E6%9C%BA%E5%88%B6%20(by%20%E8%82%96%E5%BA%94%E6%B3%A2).md)

**下面为补充**

##### Looper
- Looper除了prepare方法外，还提供了prepareMainLooper方法,这个方法主要是给主线
程也就是ActivityThread创建Looper使用的，其本质也是通过prepare方法来实现的。
- 由于主线程的Looper比较特殊，所以Looper提供了一个getMainLooper方法，通过它可以在任何地
方获取到主线程的Looper。
- Looper也是可以退出的，Looper提供了quit和quitSafely来退出一个Looper，二者的区别是：
    - quit会直接退出Looper，
    - quitSafely只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全地退出。
- Looper退出后，通过Handler发送的消息会失败，这个时候Handler的send方法会返回false。
- 在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程就会一直处于等待的状态，而如果退出Looper以后，这个线程就会立刻终止，因此建议不需要的时候终止Looper。

##### Handler
[![jgJY3d.png](https://s1.ax1x.com/2022/07/12/jgJY3d.png)](https://imgtu.com/i/jgJY3d)

