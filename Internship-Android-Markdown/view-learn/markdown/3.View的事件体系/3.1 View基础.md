## 3.1 View基础

### 3.1.1 什么是View
控件,可以是:
- view
- viewGroup

### 3.1.2 View的位置参数
- top
- bottom
- left
- right

![](https://s3.bmp.ovh/imgs/2022/07/14/f9b3453e16a0b04a.png)
可以看到这四个属性都是以父View为基准的
**Android3.0开始新增参数**
- x=left+translationX
- y=top+translationY

其中x和y是View左上角的坐标，而translationX和translationY是View左上角相对于父容器的偏移量。这几个参数也是相对于父容器的坐标，并且translationX和translationY的默认值是0

由此可以推出
- width=right-left
- height-bottom-top

需要注意的是，View在平移的过程中，top和left表示的是原始左上角的位置信息，其
值并不会发生改变，此时发生改变的是x、y、translationX和translationY这四个参数

### 3.1.3 MotionEvent和TouchSlop

#### 1. MotionEvent
在手指接触屏幕后所产生的一系列事件中，典型的事件类型有如下几种：
- ACTION_DOWN——手指刚接触屏幕；
- ACTION_MOVE——手指在屏幕上移动；
- ACTION_UP——手机从屏幕上松开的一瞬间。
- ACTION_CANCEL——由于手指滑出View或者其他情况

正常情况下，一次手指触摸屏幕的行为会触发一系列点击事件，考虑如下几种情况：
- 点击屏幕后离开松开，事件序列为DOWN -> UP；
- 点击屏幕滑动一会再松开，事件序列为DOWN -> MOVE -> … > MOVE -> UP。
- 点击屏幕滑动出View，时间序列为DOWN -> MOVE -> … > MOVE -> CANCEL。

上述三种情况是典型的事件序列，同时通过MotionEvent对象我们可以得到点击事件
发生的x和y坐标。为此，系统提供了两组方法：`getX/getY`和`getRawX/getRawY`。它们的区别其实很简单：
- getX/getY返回的是相对于当前View左上角的x和y坐标，而
- getRawX/getRawY返回的是相对于手机屏幕左上角的x和y坐标。

#### 2. TouchSlop
TouchSlop是系统所能识别出的被认为是滑动的最小距离，换句话说，当手指在屏幕
上滑动时，如果两次滑动之间的距离小于这个常量，那么系统就不认为你是在进行滑动操
作。原因很简单：滑动的距离太短，系统不认为它是滑动。这是一个常量，和设备有关，
在不同设备上这个值可能是不同的，通过如下方式即可获取这个常量：
```java
ViewConfiguration. get(getContext()).getScaledTouchSlop()。
```
**这个常量有什么意义呢？**
当我们在处理滑动时，可以利用这个常量来做一些过滤，比如当两次滑动事件的滑动距离小于这个值，我们就可以认为未达到滑动距离的临界值，因此就可以认为它们不是滑动，这样
做可以有更好的用户体验。其实如果细心的话，可以在源码中找到这个常量的定义，在
`frameworks/base/core/res/res/values/config.xml`文件中，如下所示。这
个`“config_viewConfigurationTouchSlop”`对应的就是这个常量的定义。
```java
<!--Base "touch slop" value used by ViewConfiguration as a movement threshold
where scrolling should begin. -->
<dimen name="config_viewConfigurationTouchSlop">8dp</dimen>
```

### 3.1.4 VelocityTracker、GestureDetector和Scroller

#### 1. VelocityTracker
速度追踪，用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。它的使
用过程很简单，首先，在View的onTouchEvent方法中追踪当前单击事件的速度：
```java
VelocityTracker velocityTracker = VelocityTracker.obtain();
velocityTracker.addMovement(event);
```
接着，当我们先知道当前的滑动速度时，这个时候可以采用如下方式来获得当前的速
度：
```java
velocityTracker.computeCurrentVelocity(1000);
int xVelocity = (int) velocityTracker.getXVelocity();
int yVelocity = (int) velocityTracker.getYVelocity();
```

#### 2. GestureDetector
手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。要使用
GestureDetector也不复杂，参考如下过程。
首先，需要创建一个GestureDetector对象并实现OnGestureListener接口，根据需要我
们还可以实现OnDoubleTapListener从而能够监听双击行为：
```java
GestureDetector mGestureDetector = new GestureDetector(this);
//解决长按屏幕后无法拖动的现象
mGestureDetector.setIsLongpressEnabled(false);
```
接着，接管目标View的onTouchEvent方法，在待监听View的onTouchEvent方法中添
加如下实现：
```
boolean consume = mGestureDetector.onTouchEvent(event);
return consume;
```
做完了上面两步，我们就可以有选择地实现OnGestureListener和OnDoubleTapListener
中的方法了，这两个接口中的方法介绍如表3-1所示。
![](https://s3.bmp.ovh/imgs/2022/07/14/713aec60b5d5f00a.png)

#### 3. Scroller
弹性滑动对象，用于实现View的弹性滑动。我们知道，当使用View的`scrollTo/scrollBy`方法来进行滑动时，其过程是瞬间完成的，这个没有过渡效果的滑动用户体验不好。这个时候就可以使用Scroller来实现有过渡效果的滑动，其过程不是瞬间完成的，而是在一定的时间间隔内完成的。Scroller本身无法让View弹性滑动，它需要和View的computeScroll方法配合使用才能共同完成这个功能。那么如何使用Scroller呢？它的典型代码是固定的，如下所示。至于它为什么能实现弹性滑动，[可以看这里]()
```java
Scroller scroller = new Scroller(mContext);
// 缓慢滚动到指定位置
private void smoothScrollTo(int destX,int destY) {
    int scrollX = getScrollX();
    int delta = destX -scrollX;
    // 1000ms内滑向destX，效果就是慢慢滑动
    mScroller.startScroll(scrollX,0,delta,0,1000);
    invalidate();
}
@Override
public void computeScroll() {
    if (mScroller.computeScrollOffset()) {
        scrollTo(mScroller.getCurrX(),mScroller.getCurrY());
        postInvalidate();
    }
}
```
