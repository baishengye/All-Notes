## 弹性滑动

### 3.3.1 使用Scroller

**Scroller#startScroll()**
其实只是设置了起始位置和滑动的距离以及时间,真正启动滑动的是invalidate()

**invalidate()**
invalidate()会触发View的onDraw()使View重新绘制,那么在onDraw()被调用的时候会调用computeScroll().

**computeScroll()**
computeScroll()里面就可以写我们需要的滑动逻辑了(实际还是用scrollBy/scrollTo实现的滑动),只不过computeScroller会把一大段距离分成一小段一小段的，看起来像动画
```java
if (mScroller.computeScrollOffset()) {
    scrollTo(mScroller.getCurrX(),mScroller.getCurrY());
    postInvalidate();
}
```
getCurrX()/getCurrY()就是细分后的距离,postInvalidate()会再次触发onDraw()进而触发computeScroll()，循环往复直至完成动画
```java
public boolean computeScrollOffset() {
    ...
    int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() -mStartTime);
    if (timePassed < mDuration) {
        switch (mMode) {
            case SCROLL_MODE:
            final float x = mInterpolator.getInterpolation(timePassed *mDurationReciprocal);
            mCurrX = mStartX + Math.round(x * mDeltaX);
            mCurrY = mStartY + Math.round(x * mDeltaY);
            break;
            ...
        }
    }
    return true;
}
```
其中的computeScrollOffset()起到一个计算每一小段距离的作用，类似于插值器

### 3.3.2 通过动画
```java
final int startX = 0;
final int deltaX = 100;
ValueAnimator animator = ValueAnimator.ofInt(0,1).setDuration(1000);
animator.addUpdateListener(new AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animator) {
        float fraction = animator.getAnimatedFraction();
        mButton1.scrollTo(startX + (int) (deltaX * fraction),0);
    }
});
animator.start();
```
动画+Scroller可以和Scroller的computeScroll()实现一样的效果，但是都只是把内容移动了，View实际没有动

### 3.3.3 使用延时策略
```java
private static final int MESSAGE_SCROLL_TO = 1;
private static final int FRAME_COUNT = 30;
private static final int DELAYED_TIME = 33;
private int mCount = 0;
@SuppressLint("HandlerLeak")
private Handler mHandler = new Handler() {
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case MESSAGE_SCROLL_TO: {
                mCount++;
                if (mCount <= FRAME_COUNT) {
                    float fraction = mCount / (float) FRAME_COUNT;
                    int scrollX = (int) (fraction * 100);
                    binding.btnViewAnim.scrollTo(-scrollX,0);
                    mHandler.sendEmptyMessageDelayed(MESSAGE_SCROLL_TO,DELAYED_TIME);
                }
                break;
            }
            default:
                break;
        }
    }
};
```

