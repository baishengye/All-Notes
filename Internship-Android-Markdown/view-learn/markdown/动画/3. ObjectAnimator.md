## ObjectAnimator
ObjectAnimator用起来和ValueAnimator的差别不大，只不过是ObjectAnimator把ValueAnimator封装了一层

### ofFloat()
```java

ofFloat(Object target, String propertyName, float... values)

ofFloat(T target, Property<T, Float> property,float... values)

ofMultiFloat(Object target, String propertyName,float[][]values)

ofMultiFloat(Object target, String propertyName, Path path)

ofMultiFloat(Object target, String propertyName,
            TypeConverter<T, float[]> converter, TypeEvaluator<T> evaluator, T... values)
```
可以看出我们在使用ObjectAnimator的时候只需要设置那个控件target作为动画的作用对象,然后propertyName是要操作的属性
- 要添加动画效果的对象属性必须具有 set<PropertyName>() 形式的 setter 函数（采用驼峰式大小写形式）。由于 ObjectAnimator 会在动画过程中自动更新属性，它必须能够使用此 setter 方法访问该属性。例如，如果属性名称为 foo，则需要使用 setFoo() 方法。如果此 setter 方法不存在，您有三个选择：
    - 如果您有权限，可将 setter 方法添加到类中。
    - 使用您有权更改的封装容器类，让该封装容器使用有效的 setter 方法接收值并将其转发给原始对象。
    - 改用 ValueAnimator。

#### 比如:
```java
objectAnimator1 = ObjectAnimator.ofFloat(binding.btnObjectAnimator, "translationX", 0f,600f)

objectAnimator1.apply {
    duration=3000
    repeatMode=ObjectAnimator.REVERSE
    repeatCount=0
    interpolator=AnticipateInterpolator()
}
```

#### 其他的比如
- ofInt()
- ofObject()
- ofPropertyValuesHolder()
- ofMultiInt()

都大同小异