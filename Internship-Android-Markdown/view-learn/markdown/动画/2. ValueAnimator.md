## ValueAnimator

### 1. 简介
属性动画机制中 最核心的一个类

### 2. 原理
- 通过不断控制 值 的变化，再不断 手动 赋给对象的属性，从而实现动画效果。
- 具体如图下：
![](https://upload-images.jianshu.io/upload_images/944365-e92b5c3efabbeb42.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)
从上面原理可以看出：ValueAnimator类中有3个重要方法：

1. ValueAnimator.ofInt（int values）
2. ValueAnimator.ofFloat（float values）
3. ValueAnimator.ofObject（int values）
但是其实还有另外的几个方法:
4. ValueAnimator.ofPropertyValuesHolder(PropertyValuesHolder values)
5. ValueAnimator.ofArgb(int valus)
下面我将逐一介绍。

### 3. 整型：ValueAnimator.ofInt（）

#### 3.1 作用
将初始值 以整型数值的形式 过渡到结束值

>即估值器是整型估值器 - IntEvaluator

#### 3.2 工作原理
![](https://upload-images.jianshu.io/upload_images/944365-59dc8a7bd432a0fc.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

#### 3.3 具体使用
- 因为ValueAnimator本质只是一种值的操作机制，所以下面的介绍先是展示如何改变一个值的过程（下面的实例主要讲解：如何将一个值从0平滑地过渡到3）
- 至于如何实现动画，是需要开发者手动将这些 值 赋给 对象的属性值。关于这部分在下节会进行说明。
操作值的方式 分为 XML 设置 / Java 代码设置，具体如下：
```java
/*
 * 设置方式1：xml
 */
// 步骤1：在路径 res/animator的文件夹里创建相应的动画 .xml文件 - set_animation.xml

// 步骤2：设置动画参数
// ValueAnimator采用<animator>  标签
<animator xmlns:android="http://schemas.android.com/apk/res/android"  
    android:valueFrom="0"   // 初始值
    android:valueTo="3"  // 结束值
    android:valueType="intType" // 变化值类型 ：floatType & intType

    android:duration="3000" // 动画持续时间（ms），必须设置，动画才有效果
    android:startOffset ="1000" // 动画延迟开始时间（ms）
    android:fillBefore = “true” // 动画播放完后，视图是否会停留在动画开始的状态，默认为true
    android:fillAfter = “false” // 动画播放完后，视图是否会停留在动画结束的状态，优先于fillBefore值，默认为false
    android:fillEnabled= “true” // 是否应用fillBefore值，对fillAfter值无影响，默认为true
    android:repeatMode= “restart” // 选择重复播放动画模式，restart代表正序重放，reverse代表倒序回放，默认为restart|
    android:repeatCount = “0” // 重放次数（所以动画的播放次数=重放次数+1），为infinite时无限重复
    android:interpolator = @[package:]anim/interpolator_resource // 插值器，即影响动画的播放速度,下面会详细讲
/> 

// 步骤3：启动动画
    // 载入XML动画
    Animator animator = AnimatorInflater.loadAnimator(context, R.animator.set_animation);  
    // 设置动画对象
    animator.setTarget(view);  
    // 启动动画
    animator.start();  

/*
 * 设置方式2：Java
 */
// 步骤1：设置动画属性的初始值 & 结束值
    ValueAnimator anim = ValueAnimator.ofInt(0, 3);
    // ofInt()作用：
    // 1. 创建动画实例
    // 2. 将传入的多个Int参数进行平滑过渡:此处传入0和3,表示将值从0平滑过渡到3
    // 如果传入了3个Int参数 a,b,c ,则是先从a平滑过渡到b,再从b平滑过渡到C，以此类推
    // ValueAnimator.ofInt()内置了整型估值器,直接采用默认的.不需要设置，即默认设置了如何从初始值 过渡到 结束值
    // 关于自定义插值器我将在下节进行讲解
    // 下面看看ofInt()的源码分析 ->>关注1

    // 关注1：ofInt（）源码分析
    public static ValueAnimator ofInt(int... values) {
    // 允许传入一个或多个Int参数
    // 1. 输入一个的情况（如a）：从0过渡到a；
    // 2. 输入多个的情况（如a，b，c）：先从a平滑过渡到b，再从b平滑过渡到C

    ValueAnimator anim = new ValueAnimator();
    // 创建动画对象
    anim.setIntValues(values);
    // 将传入的值赋值给动画对象
    return anim;
}

// 步骤2：设置动画的播放各种属性
    // 设置动画运行的时长
    anim.setDuration(500); 
    
    // 设置动画延迟播放时间
    anim.setStartDelay(500); 

    // 设置动画重复播放次数 = 重放次数+1
    // 动画播放次数 = infinite时,动画无限重复
    anim.setRepeatCount(0);
    
    // 设置重复播放动画模式
    anim.setRepeatMode(ValueAnimator.RESTART);
    // ValueAnimator.RESTART(默认):正序重放
    // ValueAnimator.REVERSE:倒序回放

// 步骤3：将改变的值手动赋值给对象的属性值：通过动画的更新监听器
// 设置值的更新监听器，即：值每次改变、变化一次,该方法就会被调用一次
    anim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator animation) {

        // 获得改变后的值
        int currentValue = (Integer) animation.getAnimatedValue();

        // 将改变后的值赋给对象的属性值，下面会详细说明
        View.setproperty（currentValue）；

        // 刷新视图，即重新绘制，从而实现动画效果
        View.requestLayout();
             }
        });

// 步骤4：启动动画
  anim.start();
值 从初始值 过度到 结束值 的过程如下效果图：
```
![](https://upload-images.jianshu.io/upload_images/944365-cf61973c2bcbc9ee.gif?imageMogr2/auto-orient/strip|imageView2/2/w/386/format/webp)


### 4. 浮点型：ValueAnimator.oFloat（）

#### 4.1 作用
将初始值 以浮点型数值的形式 过渡到结束值

#### 4.2 工作原理
![](https://upload-images.jianshu.io/upload_images/944365-d9bdedd5d6cb6238.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

#### 4.3 具体使用
其使用方式跟ValueAnimator.ofInt()十分类似，此处仅展示区别之处：
```java
/*
 * 设置方式1：xml
 */
<animator xmlns:android="http://schemas.android.com/apk/res/android"  
    android:valueFrom="0"  
    android:valueTo="3"  
    android:valueType="floatType" // 区别：设置为浮点型类型
    ... // 其余属性设置跟ValueAnimator.ofInt类似
    />  

/*
 * 设置方式2：Java
 */
ValueAnimator anim = ValueAnimator.ofFloat(0, 3);  
// 采用ValueAnimator.ofFloat()
// 其他使用类似ValueAnimator.ofInt（int values），此处不作过多描述
```
从上面可以看出，ValueAnimator.ofInt（）与ValueAnimator.oFloat（）仅仅只是在估值器上的区别：（即如何从初始值 过渡 到结束值）

- ValueAnimator.oFloat（）采用默认的浮点型估值器 (FloatEvaluator)
- ValueAnimator.ofInt（）采用默认的整型估值器（IntEvaluator）
在使用上完全没有区别，此处对ValueAnimator.oFloat（）的使用就不作过多描述。

### 5. 对象：ValueAnimator.ofObject（）
#### 5.1 作用
将初始值 以对象的形式 过渡到结束值

>即通过操作 对象 实现动画效果

#### 5.2 工作原理
![](https://upload-images.jianshu.io/upload_images/944365-8e6eb4174bbbd4af.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

5.3 具体使用
```java
public class Tran {
    private float x;
    private float y;

    public Tran() {
    }

    public Tran(float x, float y) {
        this.x = x;
        this.y = y;
    }

    public float getX() {
        return x;
    }

    public void setX(float x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }
}

binding.btnValueAnimator.post{
    val x = binding.btnValueAnimator.x
    valueAnimator7 = ValueAnimator.ofObject(TypeEv(),
        Tran(binding.btnValueAnimator.x, binding.btnValueAnimator.y),
        Tran(binding.btnValueAnimator.x*5 , binding.btnValueAnimator.y*5 ))
        valueAnimator7.apply {
            duration=1000
            repeatCount=0
            repeatMode=ValueAnimator.REVERSE
            addUpdateListener { animation->
                val animatedValue = animation.animatedValue as Tran
                binding.btnValueAnimator.x=animatedValue.x
                binding.btnValueAnimator.y=animatedValue.y
            }
        }
    }

```
可以看到我们使用ofObect的时候需要自己适配估值器TypeEv()
在继续讲解ValueAnimator.ofObject（）的使用前，我先讲一下估值器（TypeEvaluator）

##### 5.4 估值器（TypeEvaluator）
- 作用：设置动画 如何从初始值 过渡到 结束值 的逻辑
>插值器（Interpolator）决定 值 的变化模式（匀速、加速blabla）
>估值器（TypeEvaluator）决定 值 的具体变化数值
从上面可知：

- ValueAnimator.ofFloat（）实现了 将初始值 以浮点型的形式 过渡到结束值 的逻辑，那么这个过渡逻辑具体是怎么样的呢？
- 其实是系统内置了一个 FloatEvaluator估值器，内部实现了初始值与结束值 以浮点型的过渡逻辑
我们来看一下 FloatEvaluator的代码实现：
```java
// 步骤1：FloatEvaluator实现了TypeEvaluator接口
public class FloatEvaluator implements TypeEvaluator {  

// 步骤2：重写evaluate()
    public Object evaluate(float fraction, Object startValue, Object endValue) { 

        // 初始值过渡到结束值 的算法是：
        // 1. 用结束值减去初始值，算出它们之间的差值
        // 2. 用上述差值乘以fraction系数
        // 3. 再加上初始值，就得到当前动画的值
        float startFloat = ((Number) startValue).floatValue();  
        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);  
    }  
} 
```
- ValueAnimator.ofInt（） & ValueAnimator.ofFloat（）都具备系统内置的估值器，即FloatEvaluator & IntEvaluator
>即系统已经默认实现了 如何从初始值 过渡到 结束值 的逻辑

但对于ValueAnimator.ofObject（），从上面的工作原理可以看出并没有系统默认实现，因为对对象的动画操作复杂 & 多样，系统无法知道如何从初始对象过度到结束对象
因此，对于ValueAnimator.ofObject（），我们需自定义估值器（TypeEvaluator）来告知系统如何进行从 初始对象 过渡到 结束对象的逻辑
自定义实现的逻辑如下
```java
// 步骤1：实现TypeEvaluator接口
public class ObjectEvaluator implements TypeEvaluator{  

// 步骤2：复写evaluate()
// 作用：估值器的计算逻辑，即写入对象动画过渡的逻辑
    @Override  
    public Object evaluate(float fraction, Object startValue, Object endValue) {  
        // 参数说明
        // fraction：表示动画完成度（根据它来计算当前动画的值），也是插值器getInterpolation()的返回值
        // startValue：动画的初始值
        // endValue：动画的结束值

        // 估值器的计算逻辑
        ... 
        
        // 返回对象动画过渡逻辑计算后的值
        // 即赋给动画属性的具体数值
        return value;  
    } 
}
```
比如上面实例中的估值器为:
```java
public class TypeEv implements TypeEvaluator<Tran> {
    @Override
    public Tran evaluate(float fraction, Tran startValue, Tran endValue) {
        Tran tran = new Tran();
        tran.setX((endValue.getX()-startValue.getX())*fraction+ startValue.getX());
        tran.setY((endValue.getY()-startValue.getY())*fraction+ startValue.getY());
        return tran;
    }
}

```

特别注意
从上面可以看出，其实ValueAnimator.ofObject（）的本质还是操作 值，只是是采用将 多个值 封装到一个对象里的方式 同时对多个值一起操作而已


### 6. 对象：ValueAnimator.ofArgb（）
#### 6.1 作用
将初始值 以对象的形式 过渡到结束值

>即通过操作 对象 实现动画效果

#### 6.2 工作原理
原理与ofInt()一样

#### 6.3 具体使用
```java
valueAnimator8 = ValueAnimator.ofArgb(
            Color.parseColor("#ff0000"),
            Color.parseColor("#0000ff"),
            Color.parseColor("#ff0000")
        )
valueAnimator8.apply {
    duration=1000
    repeatCount=0
    repeatMode=ValueAnimator.REVERSE
    addUpdateListener { animation->
        val animatedValue = animation.animatedValue as Int
        binding.btnValueAnimator.setBackgroundColor(animatedValue)
    }
}
```
可以更改颜色



### 7. 对象：ValueAnimator.ofPropertyValuesHolder（）
#### 7.1 作用
- 以上的方法都只能播放一个类型的动画，除非使用AnimatorSet进行组合
- 而使用ValueAnimator.ofPropertyValuesHolder()可以直接操作多个类型动画
- 将初始值 以对象的形式 过渡到结束值

>即通过操作 对象 实现动画效果

#### 7.3 具体使用
```java
valueAnimator9 = ValueAnimator.ofPropertyValuesHolder(
            PropertyValuesHolder.ofFloat(
                "alpha",
                0f,
                1f,
                0f,
                1f
            )
        )
valueAnimator9.apply {
            duration=1000
            repeatCount=0
            repeatMode=ValueAnimator.REVERSE
        }
valueAnimator9.addUpdateListener {
            val animatedValue = it.getAnimatedValue("alpha") as Float
            binding.btnValueAnimator.alpha= animatedValue
        }
```


### 8. 与ObjectAnimator类对比
对比于属性动画中另外一个比较核心的使用类：ObjectAnimator类：

#### 6.1 相同点
其二者的本质都是相同：不断改变值，然后不断赋值给对象的属性从而实现动画效果

#### 6.2 区别
二者的区别在于：赋值给对象属性的操作是直接还是间接的。

- ValueAnimator类：不断改变值，然后手动赋值给对象的属性从而实现动画效果，是间接对对象属性进行操作；
- ObjectAnimator类：不断改变值，然后自动赋值给对象的属性从而实现动画效果，是直接对对象属性进行操作；
可以理解为：ObjectAnimator类的使用更加智能、自动化程度更高。

至此，关于属性动画中最核心的 ValueAnimator类已经讲解完毕。


本文章用于自身学习,原文章
```java
作者：Carson带你学安卓
链接：https://www.jianshu.com/p/7c95342f4bc2
来源：简书
```