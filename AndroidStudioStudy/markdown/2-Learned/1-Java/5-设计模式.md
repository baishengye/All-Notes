## 单例模式

### 饿汉式
对象创建过程就实例化
```java
/**
 * 饿汉式:空间换时间，类加载的时候就创建了实例，所以提前牺牲了空间
 */
class Singleehan{
    private static Singleehan instance=new Singleehan();
    private Singleehan(){}
    public static Singleehan getInstance(){
        return instance;
    }
}
```


### 懒汉式
```java 
/**
 * 线程不安全懒汉式:要用的时候在初始化，
 */
class Singlelanhan1 {
    private static Singlelanhan1 instance;

    private Singlelanhan1(){}
    public static Singlelanhan1 getInstance(){
        if(instance==null){
            instance=new Singlelanhan1();
        }
        return instance;
    }
    
}

/**
 * 线程安全懒汉式(双锁):要用的时候在初始化，
 */
class Singlelanhan2 {
    private static Singlelanhan2 instance;

    private Singlelanhan2(){}
    public static Singlelanhan2 getInstance(){
        if(instance==null){//第一次筛选没有创建实例的线程
            synchronized (Singlelanhan2.class){
                //假如同时有三个线程都进到这一步，线程就会阻塞，一个个执行代码块，知道执行完才用下一个线程执行
                if(instance==null){//正式创建
                    instance=new Singlelanhan2();
                }
            }
        }
        return instance;
    }
    
}

/**
 * 线程安全懒汉式(静态内部类):内部类只有在调用的时候才会类加载
 * 
 */
class Singlelanhan3 {  
    private static class SingletonHolder {  
    private static final Singlelanhan3 INSTANCE = new Singlelanhan3();  
    }  
    private Singlelanhan3 (){}  
    public static final Singlelanhan3 getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}

/**
 * 线程安全懒汉式(枚举类)
 * 它不仅能避免多线程同步问题，
 * 而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。
 */
enum Singlelanhan4 {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}
```