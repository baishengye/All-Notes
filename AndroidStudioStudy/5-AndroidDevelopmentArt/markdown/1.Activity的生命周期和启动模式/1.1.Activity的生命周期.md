## 1.1.Activity的生命周期

### 1.1.1 典型情况下的生命周期分析

**生命周期的切换过程**
1. 针对一个特定的Activity,第一次启动,回调:onCreate ->onStart -> onResume
2. 当用户打开新的Activity或者切换到桌面的时候，回调: onPause ->onStop,但是在新的Activity下面还可以看到就的Activity，那么就不会回调onStop。
3. 当用户再次回到原Activity时，回调:onRestart->onStart->onResume 
4. 当用户按Back键的时候，回调:onPause->onStop->onDestory
5. 但Activity被系统回收之后再打开，生命周期一样和1一样，但是并非是所有方法一样

**提问**
1. onStart和onResume，onPause和onStop有何不同?
   - onStart和onStop是基于能否看到Activity回调
   - onResume和onStop是基于Activity是否在前台(能否交互)回调

2. 加入当前Activity-A,而用户打开一个新Activity-B，那么B的onResume和A的onPause那个先执行,或者说B的onStart和A的onStop那个先执行?
    - Activity的请求会由Instrumentation来处理，然后它通过Binder向AMS发请求，AMS内部维护着一个ActivityStack并负责栈内的Activity的状态同步，AMS通过ActivityThread去同步,Activity的状态从而完成生命周期方法的调用。
    - 在ActivityStack中的resumeTopActivity-InnerLocked方法中，有这么一段代码：
        ```java
        // We need to start pausing the current activity so the top one
        // can be resumed...
        boolean dontWaitForPause = (next.info.flags&ActivityInfo.FLAG_RESUME_ WHILE_PAUSING) != 0;
        boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving,true,dontWaitForPause);
        if (mResumedActivity != null) {
            pausing |= startPausingLocked(userLeaving,false,true,dontWait-ForPause);
            if (DEBUG_STATES) Slog.d(TAG,"resumeTopActivityLocked: Pausing " + mResumedActivity);
        }
        ```
    - 从上述代码可以看出，在新Activity启动之前，栈顶的Activity需要先onPause后，新Activity才能启动。最终，在ActivityStackSupervisor中的realStartActivityLocked方法会调用如下代码。
        ```java
        app.thread.scheduleLaunchActivity(new Intent(r.intent),r.appToken,
            System.identityHashCode(r),r.info,new Configuration(mService.mConfiguration),
            r.compat,r.task.voiceInteractor,app.repProcState,r.icicle,r.persistentState,
            results,newIntents,!andResume,mService.isNextTransition-Forward(),
            profilerInfo);
        ```
        这个app.thread的类型是IApplicationThread，而IApplicationThread的具体实现是ActivityThread中的ApplicationThread。所以，这段代码实际上调到了ActivityThread的中，即ApplicationThread的scheduleLaunchActivity方法，而scheduleLaunchActivity方法最终会完成新Activity的onCreate、onStart、onResume的调用过程。因此，可以得出结论，是旧Activity先onPause，然后新Activity再启动。 
    -   至于ApplicationThread的scheduleLaunchActivity方法为什么会完成新Activity的
    onCreate、onStart、onResume的调用过程，请看下面的代码。scheduleLaunchActivity最终
    会调用如下方法，而如下方法的确会完成onCreate、onStart、onResume的调用过程。
        ```java
        源码：ActivityThread#handleLaunchActivity

        private void handleLaunchActivity(ActivityClientRecord r,Intent custom- Intent) {
            // If we are getting ready to gc after going to the background,well
            // we are back active so skip it.
            unscheduleGcIdler();
            mSomeActivitiesChanged = true;
            if (r.profilerInfo != null) {
                mProfiler.setProfiler(r.profilerInfo);
                mProfiler.startProfiling();
            }
            // Make sure we are running with the most recent config.
            handleConfigurationChanged(null,null);
            if (localLOGV) Slog.v(TAG,"Handling launch of " + r);
            //这里新Activity被创建出来，其onCreate和onStart会被调用
            Activity a = performLaunchActivity(r,customIntent);
            if (a != null) {
                r.createdConfig = new Configuration(mConfiguration);
                Bundle oldState = r.state;
                //这里新Activity的onResume会被调用
                handleResumeActivity(r.token,false,r.isForward,!r.activity.mFinished && !r.startsNotResumed);
                //省略
            }
        }
        ```
    - 从上面的分析可以看出，当新启动一个Activity的时候，旧Activity的onPause会先执行，然后才会启动新的Activity。到底是不是这样呢？我们写个例子验证一下，如下是2个Activity的代码，在MainActivity中单击按钮可以跳转到SecondActivity，同时为了分析我们的问题，在生命周期方法中打印出了日志，通过日志我们就能看出它们的调用顺序。

**从MainActivity跳转到SecondActivity的生命周期**
```java
不销毁MainActivity
D/demoMainActivity: onCreate
D/demoMainActivity: onStart
D/demoMainActivity: onResume
D/demoMainActivity: onPause
D/demoSecondActivity: onCreate
D/demoSecondActivity: onStart
D/demoSecondActivity: onResume
D/demoMainActivity: onStop

不销毁但是SecondActivity是dialog
D/demoMainActivity: onCreate
D/demoMainActivity: onStart
D/demoMainActivity: onResume
D/demoMainActivity: onPause
D/demoSecondActivity: onCreate
D/demoSecondActivity: onStart
D/demoSecondActivity: onResume
由于MainActivity可见，所以不会执行MainActivity#onStop

销毁MainActivity
D/demoMainActivity: onCreate
D/demoMainActivity: onStart
D/demoMainActivity: onResume
D/demoMainActivity: onPause
D/demoSecondActivity: onCreate
D/demoSecondActivity: onStart
D/demoSecondActivity: onResume
D/demoMainActivity: onStop
D/demoMainActivity: onDestroy
销毁MainActiviity会执行onDestory
```
**绝对不能在onPause中做重量级操作**

### 1.1.2 异常情况下的生命周期分析
当资源相关的系统配置发生改变以及系统内存不足的时候，Activity就有可能会被杀死

#### 情况1：资源相关的系统配置发生改变导致Activity被杀死并重新创建
比如：系统会按照当前设备的情况加载合适的Resources资源，当Activity从竖屏变到横屏时，默认情况下，Activity会先onDestory再onCreate。
生命周期
[![jsiMVg.png](https://s1.ax1x.com/2022/07/10/jsiMVg.png)](https://imgtu.com/i/jsiMVg)
- onSaveInstanceState(只会在Activity异常终止时调用)在onStop之前调用，但是和onPause的先后顺序不确定,onRestoreInstanceState在onStart调用之后
- 和Activity一样，每个View都有onSaveInstanceState和onRestoreInstanceState这两个方法，看一下它们的具体实现，就能知道系统能够自动为每个View恢复哪些数据。关于保存和恢复View层次结构，系统的工作流程是这样的：
    1. 首先Activity被意外终止时，Activity会调用onSaveInstanceState去保存数据
    2. 然后Activity会委托Window去保存数据
    3. 接着Window再委托它上面的顶级容器去保存数据。顶层容器是一个ViewGroup，一般来说它很可能是DecorView。
    4. 最后顶层容器再去一一通知它的子元素来保存数据，

这样整个数据保存过程就完成了。可以发现，这是一种典型的委托思想，上层委托下层、父容器委托子元素去处理一件事情，这种思想在Android中有很多应用，比如View的绘制过程、事件分发等都是采用类似的思想。至于数据恢复过程也是类似的，举个例子，拿TextView来说，我们分析一下它到底保存了哪些数据
```java
源码：TextView#onSaveInstanceState

@Override
public Parcelable onSaveInstanceState() {
    Parcelable superState = super.onSaveInstanceState();
    // Save state if we are forced to
    boolean save = mFreezesText;
    int start = 0;
    int end = 0;
    if (mText != null) {
        start = getSelectionStart();
        end = getSelectionEnd();
        if (start => 0 || end => 0) {
            // Or save state if there is a selection
            save = true;
        }
    }
    if (save) {
        SavedState ss = new SavedState(superState);
        // XXX Should also save the current scroll position!
        ss.selStart = start;
        ss.selEnd = end;
        if (mText instanceof Spanned) {
            Spannable sp = new SpannableStringBuilder(mText);
            if (mEditor != null) {
                removeMisspelledSpans(sp);
                sp.removeSpan(mEditor.mSuggestionRangeSpan);
            }
            ss.text = sp;
        } else {
            ss.text = mText.toString();
        }
        if (isFocused() && start => 0 && end => 0) {
            ss.frozenWithFocus = true;
        }
        ss.error = getError();
        return ss;
    }
    return superState;
}
```
**模拟**
```java
竖屏切换横屏:

D/demoMainActivity: onPause
D/demoMainActivity: onStop
D/demoMainActivity: onSaveInstanceState
D/demoMainActivity: onDestroy
D/demoMainActivity: onCreate
D/demoMainActivity: onCreate||restore test_text:测试
D/demoMainActivity: onStart
D/demoMainActivity: onRestoreInstanceState
D/demoMainActivity: onRestoreInstanceState||restore test_text:测试
D/demoMainActivity: onResume
D/demoMainActivity: onPause
D/demoMainActivity: onStop
D/demoMainActivity: onSaveInstanceState
D/demoMainActivity: onDestroy
D/demoMainActivity: onCreate
D/demoMainActivity: onCreate||restore test_text:测试
D/demoMainActivity: onStart
D/demoMainActivity: onRestoreInstanceState
D/demoMainActivity: onRestoreInstanceState||restore test_text:测试
D/demoMainActivity: onResume
```

#### 2. 情况2：资源内存不足导致低优先级的Activity被杀死
数据存储和恢复过程和情况1完全一致。Activity按照优先级从高到低，可以分为如下三种：
1. 前台Activity——正在和用户交互的Activity，优先级最高。
2. 可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和用户直接交互。
3. 后台Activity——已经被暂停的Activity，比如执行了onStop，优先级最低。

如果一个进程中没有四大组件在执行，那么这个进程将很快被系统杀死，因此，一些后台工作不适合脱离四大组件而独自运行在后台中，这样进程很容易被杀死。比较好的方法是将后台工作放入Service中从而保证进程有一定的优先级，这样就不会轻易地被系统杀死。

#### 如何不重新创建Activity
```java
android:configChanges="orientation" 屏幕旋转时不重建
```
**configChanges相关参数**
[![jsE50f.png](https://s1.ax1x.com/2022/07/10/jsE50f.png)](https://imgtu.com/i/jsE50f)
```java
MainActivity
<activity
    android:name=".MainActivity"
    android:exported="true"
    android:configChanges="orientation|screenSize"/>

MainActivity#onConfigurationChanged
@Override
public void onConfigurationChanged(@NonNull Confi

guration newConfig) {
    super.onConfigurationChanged(newConfig);

    Log.d(TAG,"onConfigurationChanged");
    Log.d(TAG,"onConfigurationChanged|newOrientation: "+newConfig.orientation);
}
```
如此设置后:
```java
D/demoMainActivity: onConfigurationChanged
D/demoMainActivity: onConfigurationChanged|newOrientation: 2
D/demoMainActivity: onConfigurationChanged
D/demoMainActivity: onConfigurationChanged|newOrientation: 1
```
Activity的确没有重新创建，并且也没有调用onSaveInstanceState
和onRestoreInstanceState来存储和恢复数据，取而代之的是系统调用了Activity#onConfigurationChanged方法，这个时候我们就可以做一些自己的特殊处理了


