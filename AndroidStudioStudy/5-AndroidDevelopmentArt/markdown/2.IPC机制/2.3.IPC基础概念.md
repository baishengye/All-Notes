## 2.3.IPC基础概念

### 2.3.1 Serralizable接口
```java
public class User implements Serializable {
    private static final long serialVersionUID = 519067123721295773L;
    public int userId;
    public String userName;
    public boolean isMale;
    ...
}
```
- 静态成员变量属于类不属于对象，所以不会参与序列化过程
- 其次用transient关键字标记的成员变量不参与序列化过程

#### serialVersionUID的作用
- 原则上序列化后的数据中的serialVersionUID只有和当前类的serialVersionUID相同才能够正常地被反序列化
    ```java
    serialVersionUID的详细工作机制是这样的：
    序列化的时候系统会把当前类的serialVersionUID写入序列化的文件中（也可能是其他中介），
    当反序列化的时候系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，
    如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；
    否则就说明当前类和序列化的类相比发生了某些变换，比如成员变量的数量、类型可能发生了改变，这个时候是无法正常反序列化的
    ```
- **如果不手动指定serialVersionUID的值**，反序列化时当前类有所改变，比如增加或者删除了某些成员变量，那么系统就会重新计算当前类的hash值并把它赋值给serialVersionUID，这个时候当前类的serialVersionUID就和序列化的数据中的serialVersionUID不一致，于是反序列化失败，程序就会出现crash。
- **当我们手动指定了它以后**，就可以在很大程度上避免反序列化过程的失败。比如当版本升级后，我们可能删除了某个成员变量也可能增加了一些新的成员变量，这个时候我们的反向序列化过程仍然能够成功，程序仍然能够最大限度地恢复数据，
- **如果类结构发生了非常规性改变**，比如修改了类名，修改了成员变量的类型，这个时候尽管serialVersionUID验证通过了，但是反序列化过程还是会失败，因为类结构有了毁灭性的改变，根本无法从老版本的数据中还原出一个新的类结构的对象。

### 2.3.2 Parcelable接口
```java
public class User implements Parcelable {
    public int userId;
    public String userName;
    public boolean isMale;
    public Book book;
    public User(int userId,String userName,boolean isMale) {
        this.userId = userId;
        this.userName = userName;
        this.isMale = isMale;
    }
    public int describeContents() {
        return 0;
    }
    public void writeToParcel(Parcel out,int flags) {
        out.writeInt(userId);
        out.writeString(userName);
        out.writeInt(isMale ? 1 : 0);
        out.writeParcelable(book,0);
    }
    public static final Parcelable.Creator<User> CREATOR = new Parcelable.Creator<User>() {
        public User createFromParcel(Parcel in) {
            return new User(in);
        }
        public User[] newArray(int size) {
            return new User[size];
        }
        };
        private User(Parcel in) {
            userId = in.readInt();
            userName = in.readString();
            isMale = in.readInt() == 1;
            book = in.readParcelable(Thread.currentThread().getContextClassLoader());
    }
}
```
[![jyFlb8.png](https://s1.ax1x.com/2022/07/10/jyFlb8.png)](https://imgtu.com/i/jyFlb8)

- Serializable是Java中的序列化接口，其使用起来简单但是开销很大，序列化和反序列化过程需要大量I/O操作。
- Parcelable是Android中的序列化方式，因此更适合用在Android平台上，
- Parcelable主要用在内存序列化上，通过Parcelable将对象序列化到存储设备中或者将对象序列化后通过网络传输也都是可以的，但是这个过程会稍显复杂，因此在这两种情况下建议大家使用Serializable。

### 2.3.3 Binder浅尝辄止

